## module
## JS模块方面的不足
-- JS没有模块系统，不支持封闭的作用域和依赖管理
-- 没有标准库，没有文件系统和IO流API
-- 也没有包管理系统

## CommonJS规范
-- 封装功能
-- 封闭作用域
-- 可能解决依赖问题
-- 工作效率更高，重构方便


## dirname 取得当前模块文件的所有的目录
## nodeJs加载模块的步骤（加载过程同步的）
-- 1、找对模块对应的文件
-- 2、读取此文件模块的内容
-- 3、把它封装在一个函数中并且立刻执行
-- 4、执行后把模块的module.exprot 对象赋给school

##  为什么require是同步加载？
-- 因为模块实现了缓存，当第一次加载一个模块之后，会缓存这个模块的exports对象，
以后如果再一次加载此模块，则从缓存中获取，不需要再次加载

## 在node里面模块的类型有三种
-- 1、JS模块
-- 2、json模块
    先找到文件，读取文件内容，JSON.parse转成对象返回
-- 3、node  c++扩展二进制模块
    这属于二进制模块
    当require加载一个模块的时候，回先找user，如果找不到，回在找user.json，
    如果还是找不到user.json, 如果还是找不到，会找user.node

## node亲生的模块，内置的模块放在node.exe里，加载最快的
-- fs
-- http
-- path
-- events

## 文件模块
-- 在硬盘的某个位置，加载速度非常慢，文件模块通过名称或路径来加载  文件模块的后缀有三种
-- 后缀为.js的javascript脚本，需要先读入内存在运行
-- 后缀为.json的JSON文件.fs 读入内存转换成JSON对象
-- 后缀为.node的路径编译后的二进制C/C++扩展模块文件可以直接使用
      一般自己写得到通过路径来加载别人写的通过名称取当前目录或全局的node——modules下面去找

## 第三放模块
-- 如果require函数只能指定名称则视为node_modules下面加载文件，这样的话你可以移动模块
而且不需要修改引用的模块路径
-- 第三方模块的查询路径包括module.paths 和 全局目录
